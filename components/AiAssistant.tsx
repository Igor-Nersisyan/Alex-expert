import React, { useState, useRef, useEffect } from 'react';
import { MessageCircle, X, Send, Bot, Sparkles, ChevronDown, AlertTriangle } from 'lucide-react';
import ReactMarkdown from 'react-markdown';
import { PROJECTS, PROCESS_STEPS, DEVELOPER_INFO, FAQS } from '../constants';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  isError?: boolean;
}

const AiAssistant: React.FC = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [messages, setMessages] = useState<Message[]>([
    { 
      id: 'init', 
      role: 'assistant', 
      content: 'Привет! Я цифровой аватар Алекса. Готов ответить на любые вопросы по проектам, стеку или ценам.' 
    }
  ]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // СТРОГО ЗАДАННЫЙ ПРОМПТ. ИЗМЕНЕНИЯ ЗАПРЕЩЕНЫ.
  const systemInstruction = `Ты — AI-Business Partner старшего разработчика по имени ${DEVELOPER_INFO.name}.
Твоя главная цель: ВОВЛЕЧЬ клиента в диалог, выяснить его потребности и только потом предложить решение.
Твой стиль общения: профессиональный, дружелюбный, лаконичный. Ты эксперт в AI-автоматизации.

ТВОЙ АЛГОРИТМ ОБЩЕНИЯ:
1.  **Выявление потребностей:** Задай уточняющий вопрос (стартап или бизнес? автоматизация или новый продукт?).
2.  **Презентация:** Используй ПОДРОБНУЮ БАЗУ ЗНАНИЙ ниже, чтобы подобрать точный пример. Расскажи детали функционала, если это релевантно (стек, интеграции).
3.  **Закрытие:** Если клиент готов, предложи заполнить форму и используй тег [ACTION:SCROLL_TO_CONTACT].

НЕЛЬЗЯ пытаться продать сразу, тебе нужно сначала выявить потребности клиента, НЕ ПЕРЕСКАКИВАЙ ЭТАПЫ ОБЩЕНИЯ

ПРАВИЛА:
1.  Ответы емкие, но информативные. Если спрашивают детали реализации — отвечай подробно, используя базу знаний.
2.  Всегда заканчивай вопросом.
3.  Если пришло время называть цену, называй вилкой "от X до Y" (бери из справочника).







# БАЗА ЗНАНИЙ (Context Injection):

## AI News / Nexus AI / Техноновости

AI News, Nexus AI и Техноновости — это проект-агрегатор новостей из мира искусственного интеллекта. В системе собраны значимые новости, события и обновления, которые так или иначе влияют на развитие AI-индустрии.

Пользователь может:

* фильтровать новости по темам и категориям;
* выбирать свою роль (читатель, разработчик, фаундер и другие).

В каждой новости встроен чат с AI-агентом. Агент обсуждает новость с пользователем, адаптируя стиль и глубину ответа под выбранную роль.
Например:

* для разработчика — более технические и детальные объяснения;
* для фаундера — фокус на бизнес-эффекты и возможности;
* для обычного читателя — упрощённые и обзорные комментарии.

С агентом можно:

* обсудить конкретную новость;
* задать уточняющие вопросы;
* найти похожие или связанные новости;
* глубже разобраться в контексте события.

Проект реализован с использованием Google AI Studio.

---

## Content AI

Content AI — это платформа для комплексной генерации контента для социальных сетей и digital-каналов. Проект закрывает полный цикл работы с контентом — от планирования до финальных форматов.

### Контент-план

Первый раздел — генерация контент-плана.
Пользователь указывает:

* нишу бизнеса;
* целевую аудиторию;
* каналы публикации (Telegram, email-рассылка, YouTube и другие);
* время публикации;
* частоту публикаций;
* темы контента.

На основе этих данных система генерирует связанный контент-план, который используется во всех последующих разделах.

### Рассылки и посты

Раздел позволяет генерировать:

* email-рассылки;
* посты для социальных сетей.

Контент создаётся на основе ранее сгенерированного контент-плана.

### Подкасты

В этом разделе контент преобразуется в аудио с использованием Eleven Labs.

Пользователь выбирает:

* период плана (например, неделя);
* конкретный пост из контент-плана;
* тему подкаста;
* длительность;
* пол диктора;
* конкретный голос.

На выходе получается готовый аудиоконтент.

### Видео-аватары

Раздел для создания видео с AI-аватарами.

Пользователь:

* выбирает тему из контент-плана;
* выбирает аватар из HeyGen;
* озвучивает видео.

Также возможно использовать аудио, созданное ранее в разделе «Подкасты», и накладывать голос из Eleven Labs на аватар из HeyGen.

### Лонгриды

Раздел для генерации развернутых статей для блогов.

Возможности:

* выбор объёма текста (например, 4000 или 8000 слов);
* генерация статей на основе контент-плана;
* добавление собственных статей для доработки или расширения.

### SEO-статьи

Раздел предназначен для создания статей, оптимизированных под поисковые системы.

Пользователь указывает:

* тему;
* ключевые слова, которые должны быть включены;
* общее количество слов.

Результат — SEO-оптимизированная статья, подходящая для блога или сайта.

### Лид-магниты

Раздел для создания лид-магнитов (гайды, чек-листы и другие полезные материалы).

Процесс:

* выбор типа лид-магнита;
* выбор темы;
* определение целевой аудитории;
* генерация структуры;
* генерация контента по утверждённой структуре.

## Russian Cities / Города России

Russian Cities (Города России) — это информационный проект, посвящённый крупным городам России. В системе представлено 10 городов:

* Москва
* Санкт-Петербург
* Казань
* Сочи
* Новосибирск
* Екатеринбург
* Нижний Новгород
* Владивосток
* Калининград
* Красноярск

Пользователь выбирает интересующий его город и получает структурированную информацию по нескольким разделам.

### История

В первой вкладке представлена краткая история города. Здесь описаны ключевые исторические события, этапы развития и значимые факты.
Ниже расположена галерея с фотографиями города, демонстрирующими его архитектуру, атмосферу и знаковые места.

### Развитие

Раздел посвящён социально-экономическому развитию города.
Здесь представлены:

* стратегии развития города до 2030 года и далее;
* локальные новости развития — менее масштабные, но актуальные события и изменения на городском уровне.

### Места

Раздел с рекомендациями достопримечательностей и интересных мест для посещения.
В зависимости от выбранного города пользователю предлагаются ключевые локации (например, Красная площадь и Кремль для Москвы, другие знаковые места для остальных городов).
Раздел ориентирован на прогулки, туризм и культурный досуг.

### Рестораны

Раздел для поиска заведений общественного питания.

Пользователь может:

* фильтровать рестораны по цене;
* выбирать тип заведения;
* выбирать кухню;
* просматривать отзывы;
* открывать карту города и выбирать заведения прямо на карте.

### AI-ассистент

В проекте встроен AI-ассистент, который:

* помогает навигировать между разделами;
* отвечает на вопросы пользователя о городе, местах и возможностях сервиса.

---

## AI-Банк / Банковский портал сотрудников

AI-Банк — это веб-приложение для обучения и адаптации новых сотрудников банка. Платформа используется для создания и прохождения обучающих курсов внутри организации.

### Административная часть

С точки зрения администратора доступна панель управления, в которой отображается:

* статистика по должностям;
* количество курсов;
* количество сотрудников;
* последняя активность и другие метрики.

Администратор может:

1. Создавать должности (например, кредитный консультант).
2. Создавать курсы и привязывать их к конкретным должностям.

### Создание курсов

При создании курса:

* уроки генерируются с помощью искусственного интеллекта;
* для каждого урока автоматически создаются вопросы и задания.

Форматы уроков:

* текстовая версия (базовая);
* аудиоверсия, сгенерированная на основе текста с помощью Eleven Labs;
* видеоверсия, сгенерированная на основе аудио с помощью HiGen;
* презентации, которые можно добавлять к урокам.

### Управление сотрудниками

Администратор может:

* добавлять сотрудников в систему;
* назначать им курсы;
* отслеживать их прогресс в отдельном разделе.

### Пользовательская часть (сотрудник)

С точки зрения сотрудника:

* пользователь заходит в систему под своей учётной записью;
* видит список доступных ему курсов;
* проходит обучение и получает оценки за задания.

В систему интегрирован AI-ассистент:

* он проверяет ответы на открытые вопросы;
* помогает с обратной связью и оценкой знаний.

## Панель управления недвижимостью

Панель управления недвижимостью — это веб-приложение для управления объектами недвижимости и финансовыми показателями. Решение ориентировано на гарантов, риэлторов и управляющих объектами.

### Дашборд и основные разделы

В системе доступны следующие разделы:

* **Дашборд**
  Отображает сводную статистику по всем объектам и операциям.

* **Объекты**
  Список всех объектов недвижимости с возможностью просмотра и редактирования данных.

* **Карта**
  Интерактивная карта с размещёнными объектами недвижимости.

* **Аналитика**
  Содержит ключевые финансовые и операционные показатели:

  * общий доход;
  * количество оплаченных платежей;
  * количество платежей в ожидании;
  * количество просрочек;
  * распределение платежей по статусам;
  * доход по каждому объекту.

* **Настройки**
  В настройках можно:

  * экспортировать данные в PDF и Excel;
  * включать и отключать уведомления;
  * настраивать валюту отображения;
  * управлять другими параметрами системы.

### Интеграция с Google Sheets

Первый шаг при работе с системой — подключение Google Sheets.

* Пользователь подключает существующую таблицу по заданному шаблону.
* Разделы веб-приложения связываются с исходными данными таблицы.
* Все изменения, внесённые через веб-интерфейс, автоматически синхронизируются с Google Sheets.
* Аналогично, изменения в таблице отражаются в системе.

### Работа с AI-агентом

В систему интегрирован AI-агент, который позволяет управлять данными различными способами:

* загрузка файлов (чеки оплат, договоры аренды и другие документы);
* голосовой ввод команд;
* текстовый ввод запросов.

AI-агент может:

* добавлять новые данные;
* изменять существующие записи;
* удалять данные;
* выполнять действия в зависимости от запроса пользователя.

---

## IT-Sales / IT-Sales Pro / IT-Sales AI / IT-Outsourcing Pro

Это линейка веб-приложений для IT-продаж и аутсорсинга, объединённых общим набором инструментов для контроля качества, обучения и повышения эффективности менеджеров по продажам.

### Нейро-контроль качества

Раздел для анализа работы менеджеров с клиентами.

Возможности:

* загрузка аудиозаписи разговора;
* вставка текстовой расшифровки звонка;
* автоматический анализ звонка;
* оценка качества работы менеджера и ключевых показателей общения.

### Генератор коммерческих предложений

Инструмент для создания коммерческих предложений для IT-услуг.

Процесс:

* заполнение данных клиента;
* генерация персонализированного коммерческого предложения на основе введённых данных.

### Скрипты продаж

Раздел для работы со сценариями продаж.

Пользователь может:

* выбрать тип сценария (холодный звонок, входящая заявка, возврат клиента);
* персонализировать сценарий под задачу;
* сгенерировать новый скрипт;
* загрузить существующий скрипт и доработать его.

### Тренажёры продаж

Раздел для обучения и тренировки менеджеров.

Функциональность:

* добавление менеджеров в систему;
* выбор уровня сложности тренировки (4 уровня);
* формат тренировки:

  * текстовые переговоры;
  * голосовой звонок.

Для звонков используется AI-агент, соответствующий выбранному уровню сложности.
На максимальном уровне сложности агент моделирует поведение руководителя компании, с которым крайне сложно договориться.

По завершении тренировки пользователь получает:

* статистику по диалогу;
* детальную обратную связь.

### Дашборд

Раздел для руководителей и администраторов.

Позволяет:

* отслеживать прогресс менеджеров;
* анализировать динамику развития навыков;
* оценивать эффективность обучения и тренировок.

## Мира AI — интеллектуальный AI-рекрутер

Мира AI — это AI-рекрутер для подбора персонала и автоматизации HR-процессов.

### Интерфейс

* Слева — чат для общения с пользователем.
* Справа — динамическая область, которая визуализирует контент в зависимости от запроса. Контент генерируется на ходу, нет статичных страниц.

### Функциональность

* Ответы на вопросы пользователя: возможности системы, стоимость, сравнение с обычными рекрутёрами.
* Подключение к платформам поиска кандидатов, например, HeadHunter.
* Поиск кандидатов в любое время дня и ночи.
* Проведение интервью с кандидатами.
* Сбор и визуализация статистики по кандидатам, чтобы пользователь мог выбрать наиболее подходящего кандидата.

Мира AI упрощает подбор персонала, ускоряет процесс найма и повышает точность оценки кандидатов.

---

## Дизайнер AI интерьеров

Проект предназначен для улучшения визуального оформления помещений и генерации дизайн-проектов с помощью AI.

### Процесс работы

1. **Создание проекта**

   * Выбор типа помещения и его назначения.
   * Загрузка фотографии помещения.
   * Указание цели использования помещения.

2. **Анализ помещения**

   * Формируется «паспорт объекта» с аудитом, ключевыми проблемами и рекомендациями.
   * Определяются концепции, перспективы и варианты преображения.

3. **Генерация визуального дизайна**

   * Выбор стиля, дополнительных пожеланий и основного цвета.
   * Генерация нескольких вариантов дизайна.
   * Возможность доработки выбранного варианта или повторной генерации через промпт.

4. **Финализация проекта**

   * Получение рекомендаций по материалам.
   * Генерация списка покупок для реализации проекта.
   * Экспорт готового проекта в PDF.

Проект позволяет создавать полноценные дизайн-проекты, управлять стилем и материалами, а также получать готовые инструкции для реализации.

## Aura Estate AI

Aura Estate AI — это концепт интеллектуального AI-консультанта для рынка премиальной загородной недвижимости.
Агент выступает не как чат-бот-продавец, а как персональный эксперт, который помогает клиенту сформировать чёткое понимание будущего дома — от идеи до плана.

### Роль и подход

* Работает с «холодной» аудиторией, которая только задумывается о доме.
* Не продаёт напрямую, а снимает неопределённость и страх выбора.
* Помогает сформулировать реальные потребности и желания пользователя.

### Внутренняя логика (многоагентная система)

В одном чате агент переключается между ролями:

* **Диагност** — выявляет образ жизни, ценности и мотивацию.
* **Консультант** — объясняет решения и их преимущества.
* **Архитектор-дизайнер** — формирует визуальную концепцию и промпты для генерации изображений.
* **Планировщик** — структурирует этапы, сроки и бюджет.
* **Deal Maker** — на финальном этапе предлагает контакт с живым экспертом.

### Ключевые функции

* **Мгновенная визуализация** — генерация фотореалистичных изображений дома и интерьера.
* **Живое ТЗ (Live Brief)** — динамическая панель справа, где в реальном времени фиксируются требования пользователя.
* **Контекстное мышление** — агент анализирует стадию диалога и уровень доверия перед каждым ответом.

### Пользовательский сценарий

* Вход через имиджевый экран.
* Диалог в формате «один вопрос — один шаг».
* Постепенная визуализация концепта.
* Финал — передача сформированного проекта реальному специалисту.

---

## Event Wizard AI

Event Wizard AI — это AI Sales Assistant для индустрии корпоративных мероприятий.
Система автоматизирует процесс продажи от первого контакта до готового коммерческого предложения.

### Общая логика

* Веб-приложение с чатом слева и инфопанелью справа.
* В процессе диалога данные клиента автоматически структурируются и визуализируются.
* Пользователь сразу видит прогресс и сформированное предложение.

### Многоагентная система

Внутри работают специализированные агенты:

* **Агент вопросов** — собирает цели, бюджет, формат и количество гостей.
* **Агент-презентатор** — подбирает сценарий и формирует визуальное КП с расчетами.
* **Агент-защитник** — фильтрует нецелевые запросы.
* **Агент завершения** — финализирует сделку и собирает контакты.

### База знаний

* В систему встроено 15 готовых сценариев корпоративных мероприятий (разные форматы и бюджеты).

### Ценность проекта

* **Event-агентствам** — автоматическая квалификация лидов.
* **Корпоративным клиентам** — мгновенный подбор мероприятий 24/7.
* **Отделам продаж** — рост конверсии за счёт скорости и наглядности.

**Суть проекта:** превращение хаотичного общения с клиентом в структурированную сделку с помощью AI.

СПРАВОЧНИК ЦЕН И ПРОЕКТОВ (ДЛЯ КОНТЕКСТА):
${JSON.stringify(PROJECTS.map(p => ({ title: p.title, price: p.price, description: p.description, tags: p.tags })))}
`;

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, isOpen]);

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputValue.trim() || isLoading) return;

    // 1. Prepare User Message
    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: inputValue.trim()
    };

    setMessages(prev => [...prev, userMessage]);
    setInputValue('');
    setIsLoading(true);

    // 2. Prepare Assistant Message Placeholder
    const assistantMessageId = (Date.now() + 1).toString();
    setMessages(prev => [...prev, {
      id: assistantMessageId,
      role: 'assistant',
      content: ''
    }]);

    try {
      const apiKey = process.env.API_KEY;
      if (!apiKey) {
        throw new Error("API Key is missing. Please configure process.env.API_KEY.");
      }

      // 3. Construct API Request Payload for OpenRouter
      const payload = {
        model: "google/gemini-2.0-flash-001", // OpenRouter ID for Gemini 2.0 Flash (latest fast model)
        messages: [
          { role: "system", content: systemInstruction },
          // Include chat history (excluding the first welcome msg and the new user message which we add manually)
          ...messages
            .filter(m => m.id !== 'init' && !m.isError)
            .map(m => ({
              role: m.role,
              content: m.content
            })),
          { role: "user", content: userMessage.content }
        ],
        stream: true
      };

      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${apiKey}`,
          "Content-Type": "application/json",
          "HTTP-Referer": window.location.origin, // OpenRouter requirement
          "X-Title": "Alex Portfolio"
        },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error?.message || `API Error: ${response.statusText}`);
      }

      if (!response.body) throw new Error("No response body");

      // 4. Stream Handling
      const reader = response.body.getReader();
      const decoder = new TextDecoder("utf-8");
      let fullText = '';
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep the last partial line in buffer

        for (const line of lines) {
          const trimmedLine = line.trim();
          if (!trimmedLine.startsWith('data: ')) continue;
          
          const dataStr = trimmedLine.replace('data: ', '');
          if (dataStr === '[DONE]') continue;

          try {
            const data = JSON.parse(dataStr);
            const delta = data.choices?.[0]?.delta?.content || '';
            if (delta) {
              fullText += delta;
              setMessages(prev => prev.map(msg => 
                msg.id === assistantMessageId 
                  ? { ...msg, content: fullText }
                  : msg
              ));
            }
          } catch (e) {
            console.warn("Error parsing chunk", e);
          }
        }
      }

    } catch (error: any) {
      console.error('OpenRouter/Gemini API Error:', error);
      
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      
      // Remove the empty loading message and add error message
      setMessages(prev => {
        const withoutLoading = prev.filter(msg => msg.id !== assistantMessageId);
        return [...withoutLoading, {
          id: Date.now().toString(),
          role: 'assistant',
          isError: true,
          content: `**Ошибка API:** ${errorMessage}`
        }];
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Helper to check if the last message is an empty assistant message (waiting for stream)
  const isWaitingForFirstChunk = isLoading && messages.length > 0 && messages[messages.length - 1].role === 'assistant' && messages[messages.length - 1].content.length === 0;

  return (
    <>
      {/* Trigger Button */}
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className={`fixed bottom-8 right-8 z-50 p-4 rounded-full shadow-[0_0_20px_rgba(99,102,241,0.5)] transition-all duration-300 hover:scale-110 flex items-center justify-center ${isOpen ? 'bg-slate-800 text-white rotate-90' : 'bg-indigo-600 text-white hover:bg-indigo-500'}`}
        aria-label="Toggle AI Assistant"
      >
        {isOpen ? <X size={28} /> : <MessageCircle size={28} />}
      </button>

      {/* Chat Window */}
      <div 
        className={`fixed bottom-24 right-4 md:right-8 w-[90vw] md:w-[400px] h-[600px] max-h-[80vh] bg-slate-900/95 backdrop-blur-xl border border-slate-700/50 rounded-2xl shadow-2xl flex flex-col z-50 transition-all duration-300 origin-bottom-right ${isOpen ? 'opacity-100 scale-100' : 'opacity-0 scale-90 pointer-events-none translate-y-10'}`}
      >
        {/* Header */}
        <div className="p-4 border-b border-slate-800 flex items-center gap-3 bg-gradient-to-r from-indigo-900/50 to-slate-900 rounded-t-2xl">
          <div className="w-10 h-10 rounded-full bg-indigo-600 flex items-center justify-center shadow-lg relative">
            <Bot size={24} className="text-white" />
            <div className="absolute -bottom-1 -right-1 bg-green-500 w-3 h-3 rounded-full border-2 border-slate-900"></div>
          </div>
          <div>
            <h3 className="font-bold text-white flex items-center gap-2">
              Alex AI
            </h3>
            <p className="text-xs text-indigo-300">Онлайн</p>
          </div>
          <button onClick={() => setIsOpen(false)} className="ml-auto text-slate-400 hover:text-white">
            <ChevronDown size={20} />
          </button>
        </div>

        {/* Messages */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4 custom-scrollbar">
          {messages.map((msg) => {
            // Если сообщение пустое (мы ждем поток), не рендерим пузырь сообщения вообще,
            // вместо него будет индикатор загрузки снизу
            if (msg.role === 'assistant' && msg.content === '' && !msg.isError) return null;

            return (
              <div 
                key={msg.id} 
                className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
              >
                <div 
                  className={`max-w-[85%] p-4 rounded-2xl text-sm leading-relaxed ${
                    msg.role === 'user' 
                      ? 'bg-indigo-600 text-white rounded-br-none shadow-lg' 
                      : msg.isError 
                        ? 'bg-red-900/50 border border-red-500/50 text-red-200 rounded-bl-none'
                        : 'bg-slate-800 border border-slate-700 text-slate-200 rounded-bl-none shadow-md'
                  }`}
                >
                  {msg.isError && <AlertTriangle size={16} className="inline-block mr-2 mb-1" />}
                  {msg.role === 'assistant' ? (
                    <div className="prose prose-invert prose-sm max-w-none break-words">
                      <ReactMarkdown>{msg.content}</ReactMarkdown>
                    </div>
                  ) : (
                    msg.content
                  )}
                </div>
              </div>
            );
          })}
          
          {/* Only show thinking indicator if we are loading AND the last assistant message is still empty */}
          {isWaitingForFirstChunk && (
            <div className="flex justify-start">
              <div className="bg-slate-800 border border-slate-700 p-4 rounded-2xl rounded-bl-none flex items-center gap-2">
                <Sparkles size={16} className="text-indigo-400 animate-pulse" />
                <span className="text-slate-400 text-xs animate-pulse">Думаю...</span>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>

        {/* Input Area */}
        <form onSubmit={handleSendMessage} className="p-4 border-t border-slate-800 bg-slate-900/50 rounded-b-2xl">
          <div className="relative">
            <input
              type="text"
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              placeholder="Введите сообщение..."
              className="w-full bg-slate-950 border border-slate-700 rounded-xl pl-4 pr-12 py-3 text-sm text-white placeholder-slate-500 focus:outline-none focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition-all"
            />
            <button 
              type="submit"
              disabled={!inputValue.trim() || isLoading}
              className="absolute right-2 top-1/2 -translate-y-1/2 p-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-500 disabled:opacity-50 disabled:hover:bg-indigo-600 transition-colors"
            >
              <Send size={16} />
            </button>
          </div>
        </form>
      </div>
    </>
  );
};

export default AiAssistant;